# 📱 프로젝트 개요

> 작성일: 2025-12-15
> 작성자: jimmy

## Logger란?

Logger는 iOS 애플리케이션을 위한 유연하고 확장 가능한 로깅 프레임워크입니다. Swift의 Actor를 활용한 스레드 안전한 설계와 다양한 출력 대상 지원이 특징입니다.

## 주요 기능

### 1. 다중 출력 대상 (Multi-Destination)

하나의 로그를 여러 곳에 동시에 출력할 수 있습니다:

| Destination | 설명 | 용도 |
|-------------|------|------|
| Console | 콘솔 출력 | 개발 중 디버깅 |
| OSLog | Apple 시스템 로그 | Instruments 연동, 시스템 콘솔 |
| File | 파일 저장 | 오프라인 분석, 로그 업로드 |
| Sentry | 에러 모니터링 | 크래시 추적, 이슈 관리 |
| Datadog | 로그 분석 | 대규모 로그 분석, 메트릭 |
| Firebase | Crashlytics | 크래시 리포팅 |

### 2. 로그 레벨

6단계의 로그 레벨로 세밀한 제어가 가능합니다:

```
verbose → debug → info → warning → error → fatal
   0        1       2       3         4       5
```

| 레벨 | 이모지 | 설명 | 사용 예시 |
|-----|-------|------|----------|
| verbose | 📝 | 가장 상세한 추적 | 함수 진입/퇴출, 변수 값 |
| debug | 🔍 | 디버깅 정보 | API 요청 상세, 상태 변화 |
| info | ℹ️ | 일반 정보 | 사용자 액션, 화면 전환 |
| warning | ⚠️ | 잠재적 문제 | 토큰 만료 임박, 메모리 부족 |
| error | ❌ | 오류 발생 | API 실패, 파싱 에러 |
| fatal | 💀 | 치명적 오류 | 앱 크래시, 데이터 손상 |

### 3. 민감정보 자동 마스킹

로그에 포함된 민감정보를 자동으로 마스킹합니다:

```
원본: "사용자 이메일: john@example.com"
출력: "사용자 이메일: [EMAIL]"

원본: "카드번호: 1234-5678-9012-3456"
출력: "카드번호: [CREDIT_CARD]"
```

기본 지원 패턴:
- 이메일 주소
- 신용카드 번호
- 전화번호
- IP 주소
- JWT 토큰
- 비밀번호 필드

### 4. 로그 샘플링

프로덕션 환경에서 로그 볼륨을 제어합니다:

```swift
// 프로덕션 샘플링 정책
SamplingPolicy(
    defaultRate: 0.1,        // 기본 10% 수집
    ratesByLevel: [
        .verbose: 0.01,      // verbose는 1%만
        .debug: 0.05,        // debug는 5%
        .warning: 0.5        // warning은 50%
    ],
    alwaysIncludeLevels: [.error, .fatal]  // 에러는 100%
)
```

### 5. 로그 버퍼링

효율적인 배치 처리를 위한 버퍼링:

```swift
LogBufferPolicy(
    maxSize: 100,           // 100개 쌓이면 플러시
    flushInterval: 5.0,     // 5초마다 자동 플러시
    flushOnLevel: .error,   // 에러 발생 시 즉시 플러시
    flushOnBackground: true // 백그라운드 진입 시 플러시
)
```

### 6. 성능 추적 (Performance Tracing)

코드 실행 시간을 측정하고 추적합니다:

```swift
// 자동 측정
let result = await Logger.shared.measure(name: "데이터 로딩") {
    await loadData()
}

// 수동 측정 (중첩 가능)
let parentId = await Logger.shared.startSpan(name: "전체 작업")
    let childId = await Logger.shared.startSpan(name: "하위 작업", parentId: parentId)
    // ...
    await Logger.shared.endSpan(id: childId)
await Logger.shared.endSpan(id: parentId)
```

## 기술 스택

| 구분 | 기술 |
|-----|------|
| 언어 | Swift 6.0 |
| 최소 지원 | iOS 15.0+ |
| 빌드 시스템 | Tuist |
| 동시성 | Swift Concurrency (Actor) |
| 외부 의존성 | 없음 (Core 모듈 기준) |

## 모듈 구성

```
Logger/
├── Logger            # 핵심 프레임워크 (의존성 없음)
├── LoggerSentry      # Sentry SDK 연동
├── LoggerDatadog     # Datadog SDK 연동
└── LoggerFirebase    # Firebase SDK 연동
```

### 모듈별 의존성

| 모듈 | 외부 의존성 |
|-----|------------|
| Logger | 없음 |
| LoggerSentry | Sentry SDK |
| LoggerDatadog | Datadog SDK |
| LoggerFirebase | Firebase Crashlytics |

## 설계 원칙

### Actor 기반 스레드 안전성

모든 Destination은 Actor로 구현되어 데이터 레이스를 원천 차단합니다:

```swift
public protocol LogDestination: Actor {
    var identifier: String { get }
    var minLevel: LogLevel { get set }
    func log(_ message: LogMessage) async
}
```

### 동기/비동기 API 모두 지원

Logger는 `await` 없이도 사용할 수 있는 Fire-and-Forget API를 제공합니다:

```swift
// 동기 API (await 불필요) - 권장
Logger.info("앱이 시작되었습니다")
Logger.error("오류 발생", category: "Network")

// 비동기 API (await 필요) - 로그 완료 대기 시 사용
await Logger.shared.info("로그 완료까지 대기")
```

| API 유형 | 사용 시점 | 예시 |
|---------|---------|-----|
| 동기 | 일반 로깅, UI 이벤트 | `Logger.info("...")` |
| 비동기 | 완료 대기, 테스트 | `await Logger.shared.info("...")` |

### 빌더 패턴

복잡한 설정을 쉽게 구성할 수 있습니다:

```swift
let logger = await LoggerBuilder()
    .addConsole(formatter: PrettyLogFormatter.verbose)
    .addOSLog()
    .addFile(retentionPolicy: .default)
    .withBuffer(policy: .default)
    .withSampling(policy: .production)
    .withDefaultSanitizer()
    .buildAsShared()
```

### 프로토콜 지향 설계

핵심 컴포넌트들은 프로토콜로 정의되어 쉽게 확장 가능합니다:

- `LogDestination`: 로그 출력 대상
- `LogFormatter`: 로그 포맷터
- `LogSanitizer`: 민감정보 정제기
- `UserContextProvider`: 사용자 컨텍스트 제공자

## 다음 단계

- [아키텍처](./02-아키텍처.md) - 내부 구조 자세히 알아보기
- [사용법](./03-사용법.md) - 바로 사용해보기

